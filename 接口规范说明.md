# 接口规范

## 目录

- [一、接口规范的重要性](#一接口规范的重要性)
- [二、设计原则](#二设计原则)
- [三、离线链路接口规范](#三离线链路接口规范)
  - [（1）文档解析模块](#1文档解析模块)
  - [（2）文档切片模块](#2文档切片模块)
  - [（3）文本向量化模块](#3文本向量化模块)
  - [（4）向量数据库存储模块](#4向量数据库存储模块)
- [四、在线链路模块接口规范](#四在线链路模块接口规范)
  - [（1）Query 优化模块](#1Query-优化模块)
  - [（2）文本召回模块](#2文本召回模块)
  - [（3）重排序模块](#3重排序模块)
  - [（4）生成模块](#4生成模块)

## 一、接口规范的重要性

在本项目中，接口规范扮演着举足轻重的角色，它是确保整个 RAG 系统高效、稳定运行的基石。具体而言，其重要性体现在以下几个关键方面：

- **保障系统稳定性**：统一、明确的接口规范能有效减少模块间因接口不一致引发的兼容性问题。以文档解析模块与文档切片模块为例，规范的接口确保解析后的结构化文本能准确无误地传递给切片模块进行处理，避免数据丢失或格式错误，从而保障整个离线链路数据处理的稳定性与准确性，进而提升系统的整体稳定性。
- **提升系统扩展性**：当需要引入新的算子（如新型 embedding 模型、更高效的重排序算法）或对现有算子进行升级时，遵循统一接口规范的设计，使得新模块能轻松接入系统，无需对其他模块进行大规模修改。这极大地降低了系统扩展的难度与成本，使系统能够快速适应技术发展和业务变化。
- **促进模块间高效交互**：标准化的接口为各个模块之间的交互提供了清晰、一致的规则。不同模块的开发者只需关注自身模块的功能实现，按照接口规范进行数据的输入与输出，就能实现与其他模块的无缝对接。这不仅提高了开发效率，还减少了模块间因沟通不畅导致的开发周期延长等问题，促进了整个项目开发的高效进行。

## 二、设计原则

- **一致性**：所有模块的接口设计应保持一致的风格和命名规范，便于开发者理解和使用。
- **简洁性**：接口应尽量简洁，避免不必要的复杂性，同时满足功能需求。
- **容错性**：接口应具备一定的容错能力，能够处理异常输入，并返回明确的错误信息。
- **可扩展性**：接口设计应预留扩展空间，以便未来添加新功能或支持更多模块。

## 三、离线链路接口规范

### （1）文档解析模块

**功能描述**：将多种格式的原始文档解析为结构化文本数据。

**输入参数**：

```JSON
{
  "file_path": "原始文档文件路径或二进制流",
  "parser_tool": "解析工具类型（如 'mineru'、'paddle_ocr' 等）"
}
```


**输出结果**：

```JSON
[
  Document(
    "doc_id": "文件id",
    "text": "文本内容",
    "file_name": "文件名",
    "metadata": "其他元信息"
  )
  ...
]
```


**实现逻辑**：可以通过直接调用API或者调用本地模型的两种方式，对输入的文档进行解析，对于解析后的文档内容，可以选择是否保存解析后的内容到本地

**模块联系**：文档解析模块的输出（结构化文本）将作为文档切片模块的输入。

### （2）文档切片模块

**功能描述**：将长文本拆分为适合 embedding 的短文本片段。

**输入参数**：

```json 
{
  "structured_text": "文档解析模块的输出",
  "chunk_method": "切片方法（如 'recursive'、'semantic' 等）",
  "*args": "不同切片方法对于的参数"
}
```


**输出结果**：

```json 
{
  "chunk_list": [
    {
      "chunk_method":"切片方法",
      "chunk_id": "切片 ID",
      "text": "切片文本内容",
      "metadata": "其他元信息"
    }
  ]
}
```


**模块联系**：文档切片模块的输出（切片列表）将作为文本向量化模块的输入。

### （3）文本向量化模块

**功能描述**：将切片后的文本转化为低维稠密向量，捕捉文本语义信息。

**输入参数**：

```json 
{
  "chunk_list": "文档切片模块的输出",
  "model_name": "embedding 模型名称（如 'BAAI/bge-base-zh'）",
  "device": "运行设备（如 'cuda'、'cpu'）"
}
```


**输出结果**：

```json 
{
  "vector_list": [
    {
      "chunk_id": "切片 ID",
      "vector": "向量数据",
      "text": "切片文本内容",
      "metadata": "其他元信息"
    }
  ]
}
```


**实现逻辑**：可以通过直接调用API或者调用本地模型的两种方式，对输入的文本进行embedding

**模块联系**：文本向量化模块的输出（向量列表）将作为向量数据库存储模块的输入。

### （4）向量数据库存储模块

**功能描述**：将文本向量与元信息存入向量数据库，支持高效的相似性检索。

**输入参数**：

```json 
{
  "vector_list": "文本向量化模块的输出",
  "db_type": "向量数据库类型（如 'faiss'、'elasticsearch'、'milvus'）",
  "index_path": "索引存储路径（仅对 FAISS 有效）"
}
```


**输出结果**：

```json 
{
  "status": "存储成功 / 失败状态",
  "index_id": "索引 ID",
  "storage_time": "存储耗时"
}
```


**模块联系**：向量数据库存储模块的输出（存储状态）将作为离线链路的最终结果，为在线链路提供数据支持。

## 四、在线链路模块接口规范

### （1）Query 优化模块

**功能描述**：对用户原始 Query 进行改写、拆解或扩展，提升后续检索的召回率与精度。

**输入参数**：

```json 
{
  "query": "用户原始 Query（字符串）",
  "rewrite_strategy": "改写策略（如 'llm_rewrite'、'keyword_extraction' 等）"
}
```


**输出结果**：

```json 
{
  "optimized_query": {
    "query_list": "优化后的 Query 列表",
    "keywords": "提取的关键词列表"
  }
}
```


**模块联系**：Query 优化模块的输出（优化后的 Query）将作为文本召回模块的输入。

### （2）文本召回模块

**功能描述**：根据优化后的 Query 从向量数据库中检索相关文本切片，获取候选上下文。

**输入参数**：

```json 
{
  "query": "优化后的 Query 或关键词",
  "retrieval_method": "召回方法（如 'vector_search'、'keyword_search' 等）",
  "top_k": "召回数量",
  "similarity_threshold": "相似度阈值"
}
```


**输出结果**：

```json 
{
  "retrieval_results": [
    {
      "chunk_id": "切片 ID",
      "text": "切片文本内容",
      "similarity_score": "相似度得分",
      "metadata":"召回文本的元数据信息"
    }
  ]
}
```


**模块联系**：文本召回模块的输出（召回结果）将作为重排序模块的输入。

### （3）重排序模块

**功能描述**：对召回的候选文本进行二次排序，筛选出与 Query 最相关的文本，提升精度。

**输入参数**：

```json 
{
  "retrieval_results": "文本召回模块的输出",
  "query": "原始 Query",
  "rerank_model": "重排序模型名称（如 'bge-rerank'）"
}
```


**输出结果**：

```json 
{
  "reranked_results": [
    {
      "chunk_id": "切片 ID",
      "text": "切片文本内容",
      "final_score": "最终得分"
    }
  ]
}
```


**模块联系**：重排序模块的输出（重排序结果）将作为生成模块的输入。

### （4）生成模块

**功能描述**：结合重排序后的上下文与 LLM，生成准确、简洁的回答，优化生成策略。

**输入参数**：

```json 
{
  "reranked_results": "重排序模块的输出",
  "query": "原始 Query",
  "llm_type": "LLM 类型（如 'qwen'、'chatglm' 等）",
  "llm_model_path": "LLM 模型路径（可选）"
}
```


**输出结果**：

```json 
{
  "answer": "最终回答（字符串）",
  "generation_log": {
    "llm_call_info": "LLM 调用信息",
    "generation_time": "生成耗时"
  }
}
```


**模块联系**：生成模块的输出（最终回答）将作为在线链路的最终结果，展示给用户。
